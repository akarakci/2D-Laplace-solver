
  Ata Karakci

---------------------------------------------------------------------------
Included Files:
	readme.txt
	CMakelists.txt
	directory: mesh2d
		CMakelists.txt
		karamete_mesh_generator.cpp
		karamete_mesh_generator.h
		laplace_solver.cpp
		laplace_solver.h
		mesh_generator.h
		mesh_boundary.h
		mesh_vertex.h
		mesh2d.c
	 	mesh2d.h
		potential_field.h
		v_mesh.cpp
		v_mesh.h
		vtriangle.h
		directory: tests
			CMakelists.txt
			test_driver_mesh_constructor.cpp
			test_driver_laplace_solver.cpp
			test_mesh_constructor.cpp
			test_laplace_solver.cpp
				
---------------------------------------------------------------------------

1) An instance of mesh_boundary mb is created and the boundary data is obtained from an external file "circle.dat" by input stream. An instance of karamete_mesh_generator kmg is created. By calling set_boundary method of kmg the boundary input is read to the v_mesh member of the kmg. A new C function SetBoundary is implemented in mesh2d.c which reads the boundary input into mesh2d.c in a similar way as Readfile function does. 

---------------------------------------------------------------------------

2) By calling the generate method of kmg the mesh is generated by mesh2d from this boundary input. Then the mesh is read back into v_mesh by setting its vertices and triangles. By calling the set_neighbors method neighbors of each vertex of v_mesh is put into neighbors set of v_mesh.

---------------------------------------------------------------------------

3) The mesh generator is tested in mesh_generator_test which is implemented at test_mesh_generator.cpp which takes the "circle.dat" file located in the home directory. After the mesh is created the v_mesh member of kmg is used to output a vrml file to display the mesh. The output file is "mesh.wrl" created at the home directory by calling write_triangles method of v_mesh.

---------------------------------------------------------------------------

4) The laplace_solver class is implemented with public members v_mesh and potential_filed. The potential_field class has a member set_rdist  which passes a v_mesh instance and resizes its members. All initial field values are set to 0 by default. By using the mech_vertex coordinates of the v_mesh the reciprocal distances are calculated and rdist_ and rdist_sum_ members are set. The set_node method simply sets the field value of the node.

The write_nodes method produces a vrml image of colored points at each vertex. The color values are set by vertex_color method which scales the potential values at each vertex to the unit domain. Then each color is given as a linear function of the potential as follows: the minimum potential corresponds to b=1, r=g=0. As the potential increases to the maximum value b goes to 0 and r goes to 1 and g becomes 1 at the half way and then goes to 0 at maximum.

The write_potential method produces the vrml image of the triangles with each triangle assigned to a potential value which is the average of the potentials at its vertices. Then each triangle is collared in the same way as the nodes.

The solve method of the laplace_solver passes a mesh_boundary mb and a boundary conditions vector bc and by calling karamete_mesh_generator it generates a mesh and sets its member vm_ to that of the mesh. By calling set_rdist method for vm_ the field_ member is set. 

---------------------------------------------------------------------------

5) The set_boundary_conditions method passes a vector of doubles which contains the values of the potential at the boundary vertices. Like the geometry of boundary, the boundary conditions must also be supplied by the user. A new method bnd_verts() is implemented for v_mesh which returns a vector whose elements are the v_mesh indices of the vertices of boundary. To obtain this vector "==" operator is overloaded in mesh_vertex class. By comparing each vertex with the ones on bnd_ member, which is set to mesh_boundary by mesh_generator, two vectors are created whose corresponding elements contain the v_mesh index and the mesh_boundary index of the vertices. Thus, the nth element of the bnd_verts vector is the v_mesh index of the  vertex which corresponds to the vertex with mesh_boundary index n. The ith element of the boundary conditions vector muss contain the boundary field value at the ith mesh_boundary vertex which is then written into potential_filed member of the laplace_solver class by calling set_node method. The rest of the nodes have the field value 0 by default.

For each vertex if its index is not in the bnd_verts of vm_ then the potential value is updated by calling the update_phi method which averages the potential/distance values of the neighboring vertices and divides by the sum of reciprocal distances of the neighbors. This guarantees that the potential values of the boundary remain constant. After updating the potentials the differences are put into a vector of double. The iterations continue until the maximum element of this vector is smaller than a predetermined tolerance.

---------------------------------------------------------------------------

6) A test is implemented in test_laplace_solver.cpp which takes the "circle.dat" file located in the home directory where output files created.  A mesh_boundary is set from the input file. A vector of boundary conditions is created which corresponds to a situation where the potential at one half of the boundary circle is set to a positive constant while the other half remains 0. Then the solve method of the laplace_solver is called for this mesh_boundary and boundary conditions vector. To create a finer mesh the alpha and beta parameters are set to 0.1. then by calling write_potential and write_nodes methods two vrml images "laplace_mesh.wrl" and "laplace_node.wrl" are created. The colors nicely indicate the potential variations over the domain. 
